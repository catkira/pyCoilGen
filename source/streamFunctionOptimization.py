import numpy as np
import scipy.linalg as sc

def streamFunctionOptimization(test,mesh,target,sensitivityMatrix,resistanceMatrix,tikonovFactor):
    '''returns the magnetic field generated by the optimized stream function. Version for only one coil part, else  a combined mesh is needed'''
    PotentialZeroAtBoundaryNodes = False
    sensitivityMatrixSingleZKomp=np.array(sensitivityMatrix)[2,:,:].T

    redResMat,boundaryNodes,isNotBoundaryNode = \
        reduceMatricesForBoundaryNodes(mesh, resistanceMatrix, PotentialZeroAtBoundaryNodes)
    redSenMat,boundaryNodes,isNotBoundaryNode = \
        reduceMatricesForBoundaryNodes(mesh, sensitivityMatrixSingleZKomp, PotentialZeroAtBoundaryNodes)

    reducedSF = applyTikonovRegularisation(tikonovFactor,redSenMat,redResMat, target)
    test.reducedSF = reducedSF

    if not PotentialZeroAtBoundaryNodes:
        optStreamFkt = reexpandSteamFunctionForBoundaryNodes(mesh, reducedSF, boundaryNodes, isNotBoundaryNode,
            PotentialZeroAtBoundaryNodes)
    else: optStreamFkt = reducedSF

    bFieldGeneratedByOptSF = [np.dot(np.transpose(sensitivityMatrix[0]),optStreamFkt),
        np.dot(np.transpose(sensitivityMatrix[1]), optStreamFkt), np.dot(np.transpose(sensitivityMatrix[2]), optStreamFkt)]

    updateMeshCurrentDensityMeshFaces(mesh,optStreamFkt)
    return bFieldGeneratedByOptSF,optStreamFkt

def applyTikonovRegularisation(tikonovFactor,redSenMat,redResMat, target):
    '''returns the StreamFunction for the reduced Matrix with applied trikonov regularisation.'''
    tikonovFactor = tikonovFactor*np.shape(redSenMat)[0]/np.shape(redSenMat)[1]
    tikRegMat = tikonovFactor * redResMat
    reducedSF = np.dot(sc.pinv(np.dot(np.array(redSenMat).T,redSenMat) + np.dot(np.array(tikRegMat).T,tikRegMat)),
        np.dot(np.array(redSenMat).T,target.fieldValues[2]))
    return reducedSF

def reduceMatricesForBoundaryNodes(mesh, matToRed,zeroFlag):
    '''returns the for the boundary nodes reduced matrix'''
    dimToRed = getDimToRed(matToRed)
    if True in dimToRed:
        reducedMat = getReducedMat(mesh,dimToRed,matToRed,zeroFlag)
        reducedMat,boundaryNodes,notBoundaryNodes = rearrangeReducedMat(mesh,dimToRed,reducedMat)
    else:
        print("nothing to reduce")
    return [reducedMat,boundaryNodes,notBoundaryNodes]

def rearrangeReducedMat(mesh,dimToRed,reducedMat):
    '''rearranges the reduced matrix. returns: reducedMat,boundaryNodes,notBoundaryNodes'''
    reducedMat = reducedMat.copy()
    numNodesPerBoundary,notBoundaryNodes,boundaryNodes = getBoundaryDetails(mesh) 
    boundaryNodesFirstInds = [boundaryNodes[i][0] for i in range(len(mesh.openBoundaries))]
    for dimToRedInd in np.nonzero(dimToRed)[0]:
        prevReducedMat = np.copy(reducedMat)
        index1=np.array([':']*np.ndim(prevReducedMat),dtype=object)
        index2,index3,index4,index5 = np.copy(index1),np.copy(index1),np.copy(index1),np.copy(index1)
        index1[dimToRedInd] = [i for i in range(len(mesh.openBoundaries))]
        index2[dimToRedInd] = [x for x in boundaryNodesFirstInds]
        index3[dimToRedInd] = np.arange((len(mesh.openBoundaries)),(len(notBoundaryNodes)+len(mesh.openBoundaries)))
        index4[dimToRedInd] = np.transpose(notBoundaryNodes)
        index5[dimToRedInd] = np.arange(((len(prevReducedMat[0])-(sum(numNodesPerBoundary)-len(mesh.openBoundaries)))),
            len(prevReducedMat[0]))


        if index1[0] == ':' and index2[0]==':' and index3[0] == ':' and index4[0]==':' and index5[0] == ':':
            reducedMat[:,index1[1]] = prevReducedMat[:,index2[1]]
            reducedMat[:,index3[1]] = prevReducedMat[:,index4[1]]
            reducedMat=np.delete(reducedMat,index5[1],1)
        else:
            reducedMat[index1[0]] = prevReducedMat[index2[0]]
            reducedMat[index3[0]] = prevReducedMat[index4[0]]
            reducedMat=np.delete(reducedMat,index5[0],0)
    return reducedMat,boundaryNodes,notBoundaryNodes

def getBoundaryDetails(mesh):
    '''returns numNodesPerBoundary,notBoundaryNodes,boundaryNodes for the given mesh.'''
    numNodesPerBoundary = getNumNodesPerBoundary(mesh)  
    notBoundaryNodes = getNotBoundaryNodes(mesh)
    boundaryNodes = [mesh.openBoundaries[1],mesh.openBoundaries[0]] 
    return numNodesPerBoundary,notBoundaryNodes,boundaryNodes

def getReducedMat(mesh,dimToRed,matToRed,zeroFlag):
    '''returns the reduced matrix'''
    reducedMat = matToRed.copy()
    boundaryNodes = [mesh.openBoundaries[1],mesh.openBoundaries[0]]
    for dimToRedInd in np.nonzero(dimToRed)[0]:
        index1=np.array([':']*np.ndim(reducedMat),dtype=object)
        index2=np.copy(index1)
        for boundaryInd in range(len(mesh.openBoundaries)):
            if zeroFlag:
                index1[dimToRedInd] = boundaryNodes[boundaryInd][0]
                reducedMat[index1[0:None]]=0
            else:
                index1[dimToRedInd] = boundaryNodes[boundaryInd][0]
                index2[dimToRedInd] = np.array(boundaryNodes[boundaryInd][0:None],dtype=int)
                if dimToRedInd:#(==1)
                    reducedMat[:,index1[1]] = np.sum(np.array(reducedMat)[:,index2[1]],dimToRedInd) #spalte ersetzen
                else:
                    reducedMat[index1[0]] = np.sum(np.array(reducedMat)[index2[0]],dimToRedInd)
    return reducedMat

def getNotBoundaryNodes(mesh):
    '''returns no-boundary nodes of a given mesh'''
    isNotBoundaryNode = []
    for i in range(len(mesh.vertices[:,0])):
        if mesh.boundary[i]:
            continue
        else: isNotBoundaryNode.append(i)
    return isNotBoundaryNode

def getDimToRed(matToRed):
    '''returns boolean values which dimension should be reduced'''
    dimToRed=[]
    for i in np.shape(matToRed):
        if i == len(matToRed[0]):
            dimToRed.append(True)
        else:
            dimToRed.append(False)
    return dimToRed

def getNumNodesPerBoundary(mesh):
    '''returns the number of nodes for every boundary'''
    numNodesPerBoundary=[]
    for i in range(len(mesh.openBoundaries)):
        numNodesPerBoundary.append(len(mesh.openBoundaries[i]))
    return numNodesPerBoundary

def reexpandSteamFunctionForBoundaryNodes(mesh,reducedSF,boundaryNodes,isNotBoundaryNode,zeroFlag):
    '''reexpand Streamfunction to all nodes, because the nodes of the first boundary have a potential of zero'''
    streamFunction = np.zeros(len(mesh.vertices))
    for boundaryInd in range(len(boundaryNodes)):
        if zeroFlag:
            streamFunction[boundaryNodes[boundaryInd]]=0
        else:
            streamFunction[boundaryNodes[boundaryInd]]=reducedSF[boundaryInd]

    streamFunction[isNotBoundaryNode]=reducedSF[len(boundaryNodes):]
    return streamFunction

def updateMeshCurrentDensityMeshFaces(mesh,optStreamFkt):
    '''updates the current density of the Faces in the mesh'''
    pot1 = np.transpose(np.array([optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,0]],
        optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,0]],
        optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,0]]]))
    pot2 = np.transpose(np.array([optStreamFkt[mesh.faces[:,1]]-optStreamFkt[mesh.faces[:,0]],
        optStreamFkt[mesh.faces[:,1]]-optStreamFkt[mesh.faces[:,0]],
        optStreamFkt[mesh.faces[:,1]]-optStreamFkt[mesh.faces[:,0]]]))
    pot3 = np.transpose(np.array([optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,1]],
        optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,1]],
        optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,1]]]))
    edge1 = mesh.vertices[mesh.faces[:,2]]-mesh.vertices[mesh.faces[:,0]]
    edge2 = mesh.vertices[mesh.faces[:,1]]-mesh.vertices[mesh.faces[:,0]]
    edge3 = mesh.vertices[mesh.faces[:,2]]-mesh.vertices[mesh.faces[:,1]]
    mesh.currentDensityFaces = edge1*pot1+edge2*pot2+edge3*pot3
