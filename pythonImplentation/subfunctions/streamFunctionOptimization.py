import numpy as np
import scipy.linalg as sc



def streamFunctionOptimization(mesh,target,sensitivityMatrix,resistanceMatrix,tikonovFactor):
    '''returns the magnetic field generated by the optimized stream function'''
    #Version for only one coil part, else  a combined mesh is needed
    #sensitivity matrix for each coil part is added in 3rd dimension (for only one coil part neglectable) resistance matrix something similar

    zeroFlag = False #force potential to zero at boundary nodes
    #print("sensi",np.shape(sensitivityMatrix),"resi",np.shape(resistanceMatrix))
    #print("resistanceMat",resistanceMatrix)

    #Reduce target field only to z component
    sensitivityMatrixSingle=sensitivityMatrix[2]
    targetFieldSingle = target.fieldValues

    #reduce restistanceMat for boundary nodes
    meshVertices = np.transpose(mesh.vertices)
    redResMat,boundaryNodes,isNotBoundaryNode = reduceMatricesForBoundaryNodes(resistanceMatrix,mesh.openBoundaries,meshVertices,zeroFlag)
    redSenMat,boundaryNodes,isNotBoundaryNode = reduceMatricesForBoundaryNodes(sensitivityMatrixSingle,mesh.openBoundaries,meshVertices,zeroFlag)

    #scale tikonov regularization 
    tikonovFactor = tikonovFactor*np.shape(redSenMat)[0]/np.shape(redSenMat)[1]

    #possible to ask if tikonov stream function optimization (at the moment no other possibility implemented)
    tikRegMat = tikonovFactor * redResMat
    reducedSF = np.dot(sc.pinv(np.dot(np.transpose(np.array(redSenMat)),redSenMat) + np.dot(np.transpose(np.array(tikRegMat)),tikRegMat)),np.dot(np.transpose(np.array(redSenMat)),targetFieldSingle))

    #reexpand st stream fuction
    if zeroFlag == False:
        optStreamFkt = reexpandSteamFunctionForBoundaryNodes(mesh,reducedSF,boundaryNodes,isNotBoundaryNode,zeroFlag)
    else: optStreamFkt = reducedSF

    #calculate the magnetic field generated by the optimized stream function
    bFieldOptSF = [sensitivityMatrix[0]*optStreamFkt, sensitivityMatrix[1]*optStreamFkt, sensitivityMatrix[2]*optStreamFkt]

    #seperate to meshes - not needed in the moment

    #calc resulting current density of mesh faces
    updateMeshCurrentDensityFaces(mesh,optStreamFkt)
    return bFieldOptSF



def reduceMatricesForBoundaryNodes(matToRed,meshBoundaries,meshVertices,zeroFlag):#Correct!! :))
    numNodes = len(matToRed[0])
    dimToRed=[]
    for i in np.shape(matToRed): 
        if i == numNodes: dimToRed.append(True)
        else: dimToRed.append(False)
    numBoundaries = len(meshBoundaries)
    numNodesPerBoundary=[]
    for i in range(numBoundaries):
        numNodesPerBoundary.append(len(meshBoundaries[i]))
    
    #divide between boundary or notBoundary
    isNotBoundaryNode=[]
    boundaryNodes = meshBoundaries
    for i in range(len(meshVertices[0])):
        if i in boundaryNodes[0] or i in boundaryNodes[1]:
            continue
        else: isNotBoundaryNode.append(i)

    #reduction 
    reducedMat = np.copy(matToRed)
    if True not in dimToRed:
        print("nothing to reduce")
    else: 
        for dimToRedInd in np.nonzero(dimToRed)[0]:
            index1=np.array([':']*np.ndim(matToRed),dtype=object)
            index2=np.copy(index1)
            for boundaryInd in range(numBoundaries):
                if zeroFlag:
                    index1[dimToRedInd] = boundaryNodes[boundaryInd][0]
                    reducedMat[index1[0:None]]=0
                else:
                    index1[dimToRedInd] = boundaryNodes[boundaryInd][0]
                    index2[dimToRedInd] = np.array(boundaryNodes[boundaryInd][0:None],dtype=int)
                    if index2[0] == ':' and index1[0]==':':
                        reducedMat[:,(index1[1]-1)] = np.sum(np.array(reducedMat)[:,index2[1]-1],dimToRedInd)#spalte ersetzen 
                    else:
                        reducedMat[index1[0]-1] = np.sum(np.array(reducedMat)[index2[0]-1],dimToRedInd)

        #rearange the matrix to its reduces form
        boundaryNodesFirstInds = [boundaryNodes[i][0] for i in range(numBoundaries)]
        for dimToRedInd in np.nonzero(dimToRed)[0]:
            prevReducedMat = np.copy(reducedMat)
            index1=np.array([':']*np.ndim(matToRed),dtype=object)
            index2,index3,index4,index5 = np.copy(index1),np.copy(index1),np.copy(index1),np.copy(index1)
            index1[dimToRedInd] = [i for i in range(numBoundaries)]#passt
            index2[dimToRedInd] = [x-1 for x in boundaryNodesFirstInds]#passt
            index3[dimToRedInd] = np.arange((numBoundaries),(len(isNotBoundaryNode)+numBoundaries))#passt
            new=[]
            for i in isNotBoundaryNode:
                if i == 0:
                    new.append(len(matToRed))
                else: new.append(i)
            index4[dimToRedInd] = [x-1 for x in np.sort(new)]#passt
            index5[dimToRedInd] = np.arange(((numNodes-(sum(numNodesPerBoundary)-numBoundaries))), numNodes)#passt

            
            if index1[0] == ':' and index2[0]==':' and index3[0] == ':' and index4[0]==':' and index5[0] == ':':
                reducedMat[:,index1[1]] = prevReducedMat[:,index2[1]]
                reducedMat[:,index3[1]] = prevReducedMat[:,index4[1]]
                reducedMat=np.delete(reducedMat,index5[1],1)
            else:
                reducedMat[index1[0]] = prevReducedMat[index2[0]]
                reducedMat[index3[0]] = prevReducedMat[index4[0]]
                reducedMat=np.delete(reducedMat,index5[0],0)
                
    return [reducedMat,boundaryNodes,isNotBoundaryNode]

def reexpandSteamFunctionForBoundaryNodes(mesh,reducedSF,boundaryNodes,isNotBoundaryNode,zeroFlag):
    '''reexpand Streamfunction to all nodes, the nodes of the first boundary have a potential of zero'''
    streamFunction = np.zeros(len(mesh.vertices))
    for boundaryInd in range(len(boundaryNodes)):
        if zeroFlag:
            streamFunction[boundaryNodes[boundaryInd]]=0
        else:
            a = [x-1 for x in boundaryNodes[boundaryInd]]
            streamFunction[a]=reducedSF[boundaryInd]
    
    #asign the rest
    streamFunction[isNotBoundaryNode]=reducedSF[len(boundaryNodes):]
    return streamFunction




def updateMeshCurrentDensityFaces(mesh,optStreamFkt):
    '''updates the current density of the Faces in the mesh'''
    pot1 = np.transpose(np.array([optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,0]],optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,0]],optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,0]]]))
    pot2 = np.transpose(np.array([optStreamFkt[mesh.faces[:,1]]-optStreamFkt[mesh.faces[:,0]],optStreamFkt[mesh.faces[:,1]]-optStreamFkt[mesh.faces[:,0]],optStreamFkt[mesh.faces[:,1]]-optStreamFkt[mesh.faces[:,0]]]))
    pot3 = np.transpose(np.array([optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,1]],optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,1]],optStreamFkt[mesh.faces[:,2]]-optStreamFkt[mesh.faces[:,1]]]))
    edge1 = mesh.vertices[mesh.faces[:,2]]-mesh.vertices[mesh.faces[:,0]]
    edge2 = mesh.vertices[mesh.faces[:,1]]-mesh.vertices[mesh.faces[:,0]]
    edge3 = mesh.vertices[mesh.faces[:,2]]-mesh.vertices[mesh.faces[:,1]]
    mesh.currentDensityFaces = edge1*pot1+edge2*pot2+edge3*pot3